<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIVIA åˆ†æå¹³å° ç§»åŠ¨ç‰ˆ</title>
    <meta name="description" content="LIVIA DeFi åˆ†æï¼Œæ”¯æŒ BSC/ETH/Solana">
    <meta name="theme-color" content="#0af">
    <style>
        body { background: #111; color: #fff; font-family: Arial, sans-serif; margin: 0; padding: 8px; font-size: 14px; }
        .container { max-width: 100%; padding: 8px; }
        h2, h3 { margin: 8px 0; font-size: 16px; }
        table { width: 100%; border-collapse: collapse; font-size: 12px; }
        th, td { border: 1px solid #555; padding: 4px; text-align: center; }
        th { background: #222; }
        .whale { background: #ff0; color: #000; }
        .red { color: #f00; }
        .green { color: #0f0; }
        input, select, button { width: 100%; padding: 6px; margin: 4px 0; border: 1px solid #555; border-radius: 4px; font-size: 12px; background: #111; color: #fff; }
        button { background: #0af; cursor: pointer; }
        .error { color: #f00; font-size: 12px; }
        #loading { display: none; text-align: center; color: #0af; font-size: 12px; }
        #progressBar { background: #222; height: 4px; border-radius: 2px; margin: 4px 0; }
        #progressFill { background: #0af; height: 100%; width: 0%; transition: width 0.3s; }
        .chart-container { width: 100%; height: 100px; margin: 8px 0; position: relative; }
        .chart-export { position: absolute; top: 4px; right: 4px; background: #0af; color: #111; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; }
        #txModal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; overflow: auto; z-index: 9999; padding: 8px; }
        #closeBtn { position: absolute; top: 8px; right: 8px; background: #f00; color: #fff; padding: 4px 8px; border-radius: 4px; font-size: 12px; }
        #riskWarning { color: #f00; font-size: 12px; margin: 8px 0; }
        @media (max-width: 600px) { table { font-size: 10px; } .chart-container { height: 80px; } }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@6.7.0/dist/ethers.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="module">
        const { useState, useEffect } = React;
        const { render } = ReactDOM;
        const { ethers } = window.ethers;
        const { Chart } = window.Chart;

        const CHAIN_CONFIG = {
            BSC: { provider: 'https://bsc-dataseed1.binance.org', apiBase: 'https://api.bscscan.com/v2/api', decimals: 18, scan: 'bscscan.com' },
            ETH: { provider: 'https://eth.llamarpc.com', apiBase: 'https://api.etherscan.io/v2/api', decimals: 18, scan: 'etherscan.io' },
            Solana: { apiBase: 'https://pro-api.solscan.io/v2.0', decimals: 9, scan: 'solscan.io' }
        };
        const DEAD_ADDRESS = '0x000000000000000000000000000000000000dEaD';
        const ERC20_ABI = ['function decimals() view returns (uint8)', 'function totalSupply() view returns (uint256)', 'function balanceOf(address) view returns (uint256)'];

        // å†…è” Service Worker
        if ('serviceWorker' in navigator) {
            const swCode = `
                const CACHE_NAME = 'livia-cache-v1';
                const urlsToCache = ['/'];
                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
                    );
                });
                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request).then(response => response || fetch(event.request))
                    );
                });
            `;
            const blob = new Blob([swCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            navigator.serviceWorker.register(url).catch(e => console.error('SW registration failed:', e));
        }

        // å†…è” manifest
        const manifest = {
            name: 'LIVIA åˆ†æå¹³å° ç§»åŠ¨ç‰ˆ',
            short_name: 'LIVIA',
            start_url: '/',
            display: 'standalone',
            background_color: '#111',
            theme_color: '#0af',
            icons: [
                { src: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAADCAYAAABWKLW/AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAABFSURBVAgdY2CAAGMgggBjIIIAYyCCAEMghgBjIIIAYyCCAEMghgBjIIIAYyCCAEMghgBjIIIAYyCCAEMghgBjIIIAYwB5nAFi0S7qHgAAAABJRU5ErkJggg==', sizes: '192x192', type: 'image/png' }
            ]
        };
        const manifestBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
        const manifestUrl = URL.createObjectURL(manifestBlob);
        const link = document.createElement('link');
        link.rel = 'manifest';
        link.href = manifestUrl;
        document.head.appendChild(link);

        const App = () => {
            const [chain, setChain] = useState('BSC');
            const [tokenAddress, setTokenAddress] = useState('');
            const [apiKey, setApiKey] = useState('');
            const [error, setError] = useState('');
            const [loading, setLoading] = useState(false);
            const [progress, setProgress] = useState(0);
            const [holders, setHolders] = useState([]);
            const [totalSupply, setTotalSupply] = useState(0);
            const [tokenDecimals, setTokenDecimals] = useState(18);
            const [priceHistory, setPriceHistory] = useState([]);
            const [txs, setTxs] = useState([]);
            const [showModal, setShowModal] = useState(false);
            const [riskWarning, setRiskWarning] = useState('');

            useEffect(() => {
                const canvas = document.getElementById('priceChart');
                if (canvas && priceHistory.length) {
                    new Chart(canvas.getContext('2d'), {
                        type: 'line',
                        data: {
                            labels: priceHistory.map(p => p.time),
                            datasets: [{ label: 'ä»·æ ¼', data: priceHistory.map(p => p.price), borderColor: '#f0a500', backgroundColor: 'rgba(240,165,0,0.2)' }]
                        },
                        options: { responsive: true, maintainAspectRatio: false }
                    });
                }
            }, [priceHistory]);

            const initData = async () => {
                if (!tokenAddress) { setError('è¯·è¾“å…¥åˆçº¦åœ°å€'); return; }
                if (chain !== 'Solana' && !ethers.utils.isAddress(tokenAddress)) { setError('æ— æ•ˆ EVM åœ°å€'); return; }
                if (!apiKey) { setError('è¯·è¾“å…¥ API Key'); return; }
                setError('');
                setLoading(true);
                setProgress(25);
                try {
                    await getTokenInfo();
                    await renderHolderTable();
                    await updatePriceChart();
                } catch (e) {
                    setError('åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ– API Key');
                    console.error('Init failed:', e);
                } finally {
                    setLoading(false);
                    setProgress(100);
                }
            };

            const getTokenInfo = async () => {
                const config = CHAIN_CONFIG[chain];
                setTokenDecimals(config.decimals);
                if (chain === 'Solana') {
                    const data = await fetch(`${config.apiBase}/token/meta?token=${tokenAddress}&cluster=mainnet-beta`, {
                        headers: { 'Authorization': `Bearer ${apiKey}` }
                    }).then(r => r.json());
                    setTotalSupply(parseFloat(data.supply) / Math.pow(10, data.decimals));
                    setTokenDecimals(data.decimals);
                } else {
                    const provider = new ethers.providers.JsonRpcProvider(config.provider);
                    const contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
                    setTokenDecimals(Number(await contract.decimals()));
                    setTotalSupply(parseFloat(ethers.utils.formatUnits(await contract.totalSupply(), tokenDecimals)));
                }
            };

            const fetchHolders = async () => {
                const config = CHAIN_CONFIG[chain];
                const url = chain === 'Solana' ? `${config.apiBase}/token/holders?token=${tokenAddress}&limit=100&offset=0` :
                    `${config.apiBase}?module=account&action=tokenbalance&contractaddress=${tokenAddress}&tag=latest&apikey=${apiKey}`;
                const data = await fetch(url, { headers: { 'Authorization': `Bearer ${apiKey}` } }).then(r => r.json());
                if (data.status !== '1' && !data.data) throw new Error('API error');
                const result = chain === 'Solana' ? data.data : data.result;
                return result.map(h => ({
                    address: chain === 'Solana' ? h.owner : h.TokenHolderAddress,
                    balance: parseFloat(chain === 'Solana' ? h.amount : ethers.utils.formatUnits(h.TokenHolderQuantity, tokenDecimals))
                })).sort((a, b) => b.balance - a.balance);
            };

            const checkLiquidity = async () => {
                if (chain === 'Solana') return 0;
                const url = `${CHAIN_CONFIG[chain].apiBase}?module=account&action=tokenbalance&contractaddress=${tokenAddress}&address=${DEAD_ADDRESS}&tag=latest&apikey=${apiKey}`;
                const data = await fetch(url).then(r => r.json());
                if (data.status !== '1') return 0;
                return parseFloat(ethers.utils.formatUnits(data.result, tokenDecimals)) / totalSupply;
            };

            const fetchPrice = async () => {
                const cacheKey = `price_${chain}_${tokenAddress}`;
                let price = localStorage.getItem(cacheKey);
                if (!price) {
                    const url = chain === 'Solana' ? `https://price.jup.ag/v4/price?ids=${tokenAddress}&vs=So11111111111111111111111111111111111111112` :
                        `${CHAIN_CONFIG[chain].apiBase}?module=stats&action=tokenprice&contractaddress=${tokenAddress}&apikey=${apiKey}`;
                    const data = await fetch(url).then(r => r.json());
                    price = chain === 'Solana' ? data.data[tokenAddress]?.price || 0 : data.result?.price || 0;
                    localStorage.setItem(cacheKey, price);
                }
                return parseFloat(price);
            };

            const fetchTxs = async (address) => {
                const url = chain === 'Solana' ? `${CHAIN_CONFIG[chain].apiBase}/account/token-transfers?account=${address}&token=${tokenAddress}&limit=10` :
                    `${CHAIN_CONFIG[chain].apiBase}?module=account&action=tokentx&contractaddress=${tokenAddress}&address=${address}&sort=desc&apikey=${apiKey}`;
                const data = await fetch(url, { headers: { 'Authorization': `Bearer ${apiKey}` } }).then(r => r.json());
                if (data.status !== '1' && !data.data) return [];
                const result = chain === 'Solana' ? data.data : data.result;
                return result.map(tx => ({
                    hash: chain === 'Solana' ? tx.signature : tx.hash,
                    timeStamp: chain === 'Solana' ? tx.blockTime : parseInt(tx.timeStamp),
                    value: parseFloat(chain === 'Solana' ? (tx.amount || 0) : ethers.utils.formatUnits(tx.value, tokenDecimals)),
                    from: chain === 'Solana' ? tx.source : tx.from,
                    to: chain === 'Solana' ? tx.destination : tx.to
                })).filter(tx => tx.value > totalSupply * 0.05);
            };

            const calculateRisk = (balance, buySellScore = 0.5, volumeScore = 0.5, isSmartWallet = false) => {
                const score = (balance / totalSupply) * 0.4 + buySellScore * 0.3 + volumeScore * 0.2 + (isSmartWallet ? 0.1 : 0);
                return score > 0.8 ? 'é«˜' : score > 0.5 ? 'ä¸­' : 'ä½';
            };

            const renderHolderTable = async () => {
                const holders = await fetchHolders();
                if (holders.length === 0) {
                    setError('æ— æ³•è·å–æŒå¸æ•°æ®');
                    return;
                }
                setHolders(holders);
                const total = holders.reduce((a, b) => a + b.balance, 0);
                const top10Total = holders.slice(0, 10).reduce((a, b) => a + b.balance, 0);
                let warnings = [];
                if (top10Total / total > 0.5) {
                    warnings.push('å‰10åœ°å€æŒä»“å æ¯”è¿‡é«˜ï¼Œå¯èƒ½ä¸ºè²”è²…ç›˜');
                }
                const lpRatio = await checkLiquidity();
                if (lpRatio < 0.1) {
                    warnings.push(`æµåŠ¨æ€§é”å®šæ¯”ä¾‹ä½ï¼ˆ${(lpRatio * 100).toFixed(2)}%ï¼‰ï¼Œé«˜é£é™©`);
                }
                setRiskWarning(warnings.join(' | '));
            };

            const updatePriceChart = async () => {
                const price = await fetchPrice();
                const now = new Date().toLocaleTimeString();
                setPriceHistory([...priceHistory, { time: now, price }].slice(-20));
            };

            const showTx = async (address) => {
                const txs = await fetchTxs(address);
                setTxs(txs);
                setShowModal(true);
                if (txs.length > 0) {
                    setRiskWarning(prev => prev + ' | æ£€æµ‹åˆ°å¤§é¢äº¤æ˜“ï¼Œå¯èƒ½å­˜åœ¨å¼‚å¸¸');
                }
            };

            const exportCSV = () => {
                const headers = ['åœ°å€', 'æŒä»“', 'å æ¯”', 'é²¸é±¼', 'é£é™©'];
                const total = holders.reduce((a, b) => a + b.balance, 0);
                const rows = holders.map(h => [
                    h.address,
                    h.balance.toFixed(0),
                    ((h.balance / total * 100)).toFixed(2),
                    h.balance / total > 0.01 ? 'æ˜¯' : 'å¦',
                    calculateRisk(h.balance)
                ]);
                const csv = [headers, ...rows].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');
                const blob = new Blob([new Uint8Array([0xEF, 0xBB, 0xBF]), csv], { type: 'text/csv;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'holders.csv'; a.click();
                URL.revokeObjectURL(url);
            };

            const exportChart = () => {
                const canvas = document.getElementById('priceChart');
                const url = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = url; a.download = 'priceChart.png'; a.click();
                URL.revokeObjectURL(url);
            };

            return `
                <div class="container">
                    <h2>LIVIA åˆ†æå¹³å° ç§»åŠ¨ç‰ˆ</h2>
                    <div id="configPanel">
                        <label>é“¾:
                            <select onchange="this.getRootNode().host.setChain(this.value)">
                                <option>BSC</option><option>ETH</option><option>Solana</option>
                            </select>
                        </label><br>
                        <label>åˆçº¦åœ°å€:
                            <input value="${tokenAddress}" oninput="this.getRootNode().host.setTokenAddress(this.value)" placeholder="è¾“å…¥ä»£å¸åˆçº¦åœ°å€">
                        </label><br>
                        <label>API Key:
                            <input type="password" value="${apiKey}" oninput="this.getRootNode().host.setApiKey(this.value)" placeholder="BscScan/Etherscan/Solscan Key">
                        </label><br>
                        <button onclick="this.getRootNode().host.initData()">åŠ è½½æ•°æ®</button>
                        <div id="progressBar"><div id="progressFill" style="width: ${progress}%"></div></div>
                        <div id="errorMsg" class="error">${error}</div>
                        <div id="loading" style="display: ${loading ? 'block' : 'none'}">åŠ è½½ä¸­...</div>
                    </div>
                    <div id="riskWarning" class="error">${riskWarning}</div>
                    <button id="exportBtn" style="display: ${holders.length ? 'block' : 'none'}" onclick="this.getRootNode().host.exportCSV()">å¯¼å‡º CSV</button>
                    <h3>å‰100æŒå¸åœ°å€</h3>
                    <table id="holderTable">
                        <thead>
                            <tr><th>åœ°å€</th><th>æŒä»“</th><th>å æ¯”</th><th>é²¸é±¼</th><th>é£é™©</th><th>æ“ä½œ</th></tr>
                        </thead>
                        <tbody>
                            ${holders.map(h => {
                                const isWhale = h.balance / totalSupply > 0.01;
                                return `<tr class="${isWhale ? 'whale' : ''}">
                                    <td><a href="https://${CHAIN_CONFIG[chain].scan}/address/${h.address}" target="_blank">${h.address.slice(0, 6)}...</a></td>
                                    <td>${h.balance.toFixed(0)}</td>
                                    <td>${((h.balance / totalSupply * 100)).toFixed(2)}%</td>
                                    <td>${isWhale ? 'ğŸ‹' : ''}</td>
                                    <td class="${calculateRisk(h.balance) === 'é«˜' ? 'red' : 'green'}">${calculateRisk(h.balance)}</td>
                                    <td><button onclick="this.getRootNode().host.showTx('${h.address}')">æŸ¥çœ‹</button></td>
                                </tr>`;
                            }).join('')}
                        </tbody>
                    </table>
                    <div class="chart-container">
                        <h3>ä»·æ ¼è¶‹åŠ¿</h3>
                        <canvas id="priceChart"></canvas>
                        <button class="chart-export" onclick="this.getRootNode().host.exportChart()">å¯¼å‡ºå›¾è¡¨</button>
                    </div>
                    <div id="txModal" style="display: ${showModal ? 'block' : 'none'}">
                        <button id="closeBtn" onclick="this.getRootNode().host.setShowModal(false)">å…³é—­</button>
                        <div id="txDetails">
                            <h3>æœ€è¿‘äº¤æ˜“</h3>
                            ${txs.length ? `
                                <table>
                                    <tr><th>TxHash</th><th>æ—¶é—´</th><th>æ•°é‡</th><th>æ–¹å‘</th></tr>
                                    ${txs.map(t => `
                                        <tr>
                                            <td><a href="https://${CHAIN_CONFIG[chain].scan}/tx/${t.hash}" target="_blank">${t.hash.slice(0, 6)}...</a></td>
                                            <td>${new Date(t.timeStamp * 1000).toLocaleString()}</td>
                                            <td>${t.value.toFixed(0)}</td>
                                            <td>${t.from.toLowerCase() === t.address?.toLowerCase() ? 'å–å‡º' : 'ä¹°å…¥'}</td>
                                        </tr>
                                    `).join('')}
                                </table>
                            ` : '<p>æš‚æ— äº¤æ˜“è®°å½•</p>'}
                        </div>
                    </div>
                </div>
            `;
        };

        class AppComponent extends HTMLElement {
            constructor() {
                super();
                this.attachShadow({ mode: 'open' });
                this.state = {
                    chain: 'BSC',
                    tokenAddress: '',
                    apiKey: '',
                    error: '',
                    loading: false,
                    progress: 0,
                    holders: [],
                    totalSupply: 0,
                    tokenDecimals: 18,
                    priceHistory: [],
                    txs: [],
                    showModal: false,
                    riskWarning: ''
                };
            }
            setChain(value) { this.state.chain = value; this.render(); }
            setTokenAddress(value) { this.state.tokenAddress = value; this.render(); }
            setApiKey(value) { this.state.apiKey = value; this.render(); }
            setError(value) { this.state.error = value; this.render(); }
            setLoading(value) { this.state.loading = value; this.render(); }
            setProgress(value) { this.state.progress = value; this.render(); }
            setHolders(value) { this.state.holders = value; this.render(); }
            setTotalSupply(value) { this.state.totalSupply = value; this.render(); }
            setTokenDecimals(value) { this.state.tokenDecimals = value; this.render(); }
            setPriceHistory(value) { this.state.priceHistory = value; this.render(); }
            setTxs(value) { this.state.txs = value; this.render(); }
            setShowModal(value) { this.state.showModal = value; this.render(); }
            setRiskWarning(value) { this.state.riskWarning = value; this.render(); }
            initData() { App.prototype.initData.call(this.state); }
            exportCSV() { App.prototype.exportCSV.call(this.state); }
            exportChart() { App.prototype.exportChart.call(this.state); }
            showTx(address) { App.prototype.showTx.call(this.state, address); }
            render() {
                this.shadowRoot.innerHTML = App.call(this.state);
            }
            connectedCallback() { this.render(); }
        }
        customElements.define('livia-app', AppComponent);
        document.getElementById('root').innerHTML = '<livia-app></livia-app>';
    </script>
</body>
</html>